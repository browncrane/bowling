task 13:判断是否附加轮

task 12:判断是否连续全中
其中的逻辑：是否全中-> 是否最后一轮 ->是否下一轮是全中 ->是否有下两轮 -> 加成
是否补中 -> 是否最后一轮 -> 加成

task 11:全中局后是全中局，计算奖励得分
BUG_FIX:由于Scoreboard里的nextRound方法
无法识别在不同位置的同一个对象
开始考虑是否使用其他方法找nextRound
考虑同一个对象出现多次的可能性。
发现计算BonusScore的时候可能可以使用多态。

task 10:全中局后是非全中局，计算奖励得分

task 9:判断全中局

task 8:修改Round的构造函数
【如何处理Round的构造函数】单参，加补
全中轮打击的情况
    全中轮的打击记分是10
    得到全中轮当局得分

task 7:计算补中局得分

task 6：得到某一局第一次打击得分
首先要能够得到下一局的第一次击打得分
那么就要得到某一局的第一次打击得分

task 5:判断补中局。

根据现有情况，将所有局数划分为普通局，补中局和全中局；
普通局的记分情况已经完成，接下来考虑补中局。
补中局会奖励下一次打击得分。
例：[1,4] -> 5
[3,7] -> 5+10+4 = 19
[4,2] -> 19+6 = 25
首先要判断补中局，设置标记

task4:重构

task 3:在没有全中的情况下,根据打击的情况，判断当前所在轮次
例：[1,4] -> 1
[2,5] -> 2
[3,6] -> 3

task 2:在没有全中的情况下，返回指定打完回合的击中总和。
例：[1,4] -> 5
[2, 6] -> 13

task 1:没有一次全中的情况下，统计两次打击的和。
例：[1,4]第一次打中1个，第二次打中4个，则返回一共击中五个。

normal round:
    xxx
    fff
    ccxc
   .yyy
    zzz
     bbb
    .
spare round
strike round
